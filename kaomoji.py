from telegram import InlineKeyboardButton, InlineKeyboardMarkup, InlineQueryResultArticle, InputTextMessageContent
from telegram import Chat
from uuid import uuid4


class Kaomoji:

    def __init__(self, token):
        self.token = token
        self.mood = ("joy", "angry", "love", "embarrassment", "dissatisfaction", "sympathy", "sadness", "confusion",
                     "surprised", "greeting", "indifference")
        self.joy = ('o(≧▽≦)o', '(*≧ω≦*)', '(((o(*°▽°*)o)))', '<(￣︶￣)>', '(o^▽^o)', '(─‿‿─)', '☆*:.｡.o(≧▽≦)o.｡.:*☆',
                    '凸(`△´＃)', '(o･ω･o)', '(*≧ω≦*)', '(*・ω・)', 'o(>ω<)o', '(๑˘︶˘๑)', '＼(≧▽≦)／', '(´･ᴗ･ ` )', '(*°▽°*)',
                    '( ´ ▽ ` )', 'ヽ(*⌒▽⌒*)ﾉ', '(⌒‿⌒)', '(◕‿◕)', '(≧◡≦)', '(o´∀`o)', '(´｡• ω •｡`)', '(*⌒―⌒*)')
        self.angry = ('(＃`Д´)', '(`皿´＃)', '( ` ω ´ )', 'ヽ( `д´*)ノ', '(╬ Ò﹏Ó)', '(`ー´)', 'ヽ(`⌒´メ)ノ', '凸(`△´＃)',
                      '( `ε´ )', '٩(╬ʘ益ʘ╬)۶', 'ヾ(`ヘ´)ﾉﾞ', 'ヽ(‵﹏´)ノ', '(ﾒ` ﾛ ´)', '(╬`益´)', '┌∩┐(◣_◢)┌∩┐', '↑_(ΦwΦ)Ψ',
                      '＼＼٩(๑`^´๑)۶／／', '(°ㅂ°╬)', '←~(Ψ▼ｰ▼)∈', '(ノ°益°)ノ', '(҂ `з´ )', '(‡▼益▼)', '(҂` ﾛ ´)凸', '((╬◣﹏◢))')
        self.love = ('(─‿‿─)♡', '	(´,,•ω•,,)♡', '♡( ◡‿◡ )', '(❤ω❤)', '(￣З￣)', '(⌒▽⌒)♡', '(´• ω •`)', 'Σ>―(〃°ω°〃)♡→',
                     '♡＼(￣▽￣)／♡', '(´｡• ᵕ •｡`)', 'ヽ(♡‿♡)ノ', '( ´ ∀ `)ノ～ ♡', '(´ ω `♡)', 'σ(≧ε≦σ)', '(´｡• ω •｡`)',
                     '(*♡∀♡)', '♡(｡- ω -)', '( ´ ▽ ` ).｡ｏ♡', '(⇀ 3 ↼)', '(* ^ ^ * )♡', '(≧◡≦) ♡', '(っ˘з(˘⌣˘ )',
                     '(*˘︶˘ * ).: * ♡', '(♡°▽°♡)')
        self.embarrassment = ('(⌒_⌒;)', '(o^ ^o)', '(*/ω＼)', '(*/_＼)', '(*ﾉωﾉ)', '(o-_-o)', '(*μ_μ)',
                              '( ◡‿◡ *)', '(ᵔ.ᵔ)', '(*ﾉ∀`*)', '(//▽//)', '(//ω//)', '(ノ*°▽°*)', '(*^.^*)', '(*ﾉ▽ﾉ)',
                              '(￣▽￣*)ゞ', '(⁄ ⁄•⁄ω⁄•⁄ ⁄)', '(*/▽＼*)', '(⁄ ⁄>⁄ ▽ ⁄<⁄ ⁄)', '(„ಡωಡ„)', '(ง ื▿ ื)ว')
        self.dissatisfaction = ('(＃＞＜)', '(；⌣̀_⌣́)', '☆ｏ(＞＜；)○', '(￣ ￣|||)', '(＃￣0￣)', '(￣□￣」)', '(；￣Д￣)', '(〃＞＿＜;〃)',
                                '(￢_￢;)', '(」°ロ°)」', '(＞ｍ＜)', '<(￣ ﹌ ￣)>', '(￣ヘ￣)', '(」＞＜)」', 'o(>< )o', '(⇀‸↼‶)',
                                '(ᗒᗣᗕ)՞', 'ヾ( ￣O￣)ツ', '(＞﹏＜)', '(--_--)', '凸(￣ヘ￣)', '(＞﹏＜)', '(＞﹏＜)', 'ヾ( ￣O￣)ツ')
        self.sympathy = ('(ノ_<。)ヾ(´ ▽ ` )', '｡･ﾟ･(ﾉД`)ヽ(￣ω￣ )', 'ρ(- ω -、)ヾ(￣ω￣; )', 'ヽ(~_~(・_・ )ゝ', 'ヽ(￣ω￣(。。 )ゝ',
                         '(ｏ・_・)ノ”(ノ_<、)', '(っ´ω`)ﾉ(╥ω╥)', 'ヽ(~_~(・_・ )ゝ', '(; ω ; )ヾ(´∀`* )')
        self.sadness = ('(´-ω-`)', '.･ﾟﾟ･(／ω＼)･ﾟﾟ･.', '。゜゜(´Ｏ`) ゜゜。', '(-ω-、)', '｡･ﾟﾟ*(>д<)*ﾟﾟ･｡', "o(TヘTo)",
                        '(っ˘̩╭╮˘̩)っ', '(╥_╥)', '(╥﹏╥)', '(T_T)', '(｡T ω T｡)', '( ╥ω╥ )', '(μ_μ)', '(个_个)', '( ; ω ; )',
                        '･ﾟ･(｡>ω<｡)･ﾟ･', 'o(〒﹏〒)o', '(ಥ﹏ಥ)', '(｡•́︿•̀｡)', '｡ﾟ･ (>﹏<) ･ﾟ｡', '(-_-)')
        self.confusion = ('(￣ω￣;)', 'σ(￣、￣〃)', '(￣～￣;)', '(-_-;)・・・', "┐('～`;)┌", '(・_・ヾ', '(〃￣ω￣〃ゞ', '┐(￣ヘ￣;)┌',
                          '(・_・;)', '(￣_￣)・・・', '╮(￣ω￣;)╭', '(¯ . ¯;)', 'Σ(￣。￣ﾉ)', '＠_＠)', '	(・・;)ゞ', '(#•ิ_•ิ)?',
                          '(◎ ◎)ゞ', '(ーー;)', 'ლ(ಠ_ಠ ლ)', 'ლ#(¯ロ¯"ლ)', '(¯ . ¯٥)')
        self.surprised = ('w(°ｏ°)w', 'ヽ(°〇°)ﾉ', 'Σ(O_O)', 'Σ(°ロ°)', '(⊙_⊙)', '(o_O)', '(O_O;)', '(O.O)', '(°ロ°) !',
                          '(o_O) !', '∑(O_O;)', '( : ౦ ‸ ౦ : )')
        self.greeting = ('(*・ω・)ﾉ', '(￣▽￣)ノ', '(°▽°)/', '( ´ ∀ ` )ﾉ', '(^-^*)/', '(＠´ー`)ﾉﾞ', '(´• ω •`)ﾉ',
                         '( ° ∀ ° )ﾉﾞ', '(*°ｰ°)ﾉ', '(・_・)ノ', '(o´ω`o)ﾉ', "ヾ(☆'∀'☆)", "ヾ(*'▽'*)", '＼(⌒▽⌒)', 'ヾ(☆▽☆)',
                         '( ´ ▽ ` )ﾉ', 'ヾ(^ω^*)', '(・∀・)ノ', '~ヾ(・ω・)', '(^０^)ノ', '(⌒ω⌒)ﾉ', '( ´ ω ` )ノﾞ', '(￣ω￣)/',
                         '(≧▽≦)/', '(✧∀✧)/', '(o´▽`o)ﾉ', '(￣▽￣)/')
        self.indifference = ("¯\_(ツ )_/¯", 'ᕕ( ᐛ )ᕗ', 'ヽ(ー_ー )ノ', 'ヽ(　￣д￣)ノ', '┐(‘～` )┌', 'ヽ(´ー` )┌', 'ヽ(ˇヘˇ)ノ',
                             '┐(￣ヘ￣)┌', '╮(￣_￣)╭', 'ヽ(￣～￣　)ノ', '┐(￣ヮ￣)┌', '╮(￣～￣)╭')


    def inlinequery(self, update, context):
        """Handle the inline query."""

        query = update.inline_query.query

        results = [
            InlineQueryResultArticle(
                id=uuid4(),
                title=str("{}\t\t\t{}".format(emotion, getattr(self, emotion)[0])),
                input_message_content=InputTextMessageContent(getattr(self, emotion)[0])) for emotion in self.mood
                ]

        for emotion in self.mood:
            if query == emotion:
                class_member = getattr(self, query)
                results = [
                    InlineQueryResultArticle(
                        id=uuid4(),
                        title=str(class_member[j]),
                        input_message_content=InputTextMessageContent(class_member[j])) for j in range(len(class_member))
                        ]

        update.inline_query.answer(results)
